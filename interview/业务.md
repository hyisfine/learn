1. tob toc：

   1. 用户不同：b为企业政府和机构等单位，c为普通大众
   2. 产品侧重点不同：b重点关注系统的稳定性和高效性。c关注用户的体验。
   3. 盈利方式不同：b靠企业购买和提供的技术服务费用。c靠的用户充值和流量变现。
   4. 用户增长：b线性增长，c指数级增长
   5. 产品功能：b提供多个产品功能，c以一个产品功能为核心进行周边衍生
   6. 产品作用：b解决企业需求，c解决个人需求
2. saas、paas、iaas
3. 隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等 加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的 通信。隧道本身不会去解析 HTTP 请求。也就是说，请求保持原样中转给之 后的服务器。隧道会在通信双方断开连接时结束。
4. BFF：即back end for fornt end，是前端个端与后端微服务应用进行数据交互的适配和聚合层，用于聚合微服务的各项子服务，并按照前端个端要求，适配成友好且统一的接口api。
5. 网关：网关关注横切面的业务逻辑，主要关注路由切换、日志、认证等雨核心业务无关的职责，用于解耦bff层中的非核心业务，使bff的职责更明确。关注点分离。
6. 微服务架构：前端-》网关-〉bff-》微服务
7. 微前端是将Web应用由单一的单体应用转变为多个小型前端应用聚合为一的一种手段。聚合多个子应用提供统一的入口。

   1. 特点：技术栈无关：每个子应用都可以使用不同的框架，独立性强：各个子应用可以独立开发独立部署，状态隔离：运行时每个子应用之间状态隔离。
   2. 实现方式：
      1. 服务器配置路由映射到不同的应用。额外配置，丢失spa体验。
      2. iframe加载不同的页面。天然的沙河隔离，子应用嵌入简单，父子应用通信麻烦，dom隔离，全局弹框无法覆盖。事件无法穿透，页面状态无法保存。
      3. single-spa：single-spa的核心就是定义了一套**协议**。协议包含主应用的配置信息和子应用的生命周期，通过这套协议，主应用可以方便的知道在什么情况下激活哪个子应用。主应用注册子应用信息，主应用根据子的manifest.json获取子的配置信息，动态加载js文件，最后按照路由匹配执行子应用的渲染函数。基于js entry注册子应用，即通过从某一地址引入js文件来加载整个子应用。
      4. qiankun
         1. 基于html entry注册子应用，以子的项目地址加载。
         2. 子的加载：访问子的url，正则匹配其中的css js ，然后动态加载，最后把容器放置在主容器里。
         3. css 隔离：
            1. 开启js的shadow dom
            2. 运行时动态修改css 选择器，添加前缀的方法
            3. 使用css module
         4. js 隔离
            1. 在子应用挂在前对当前主应用的全局变量保存，然后恢复之前的子应用环境，在子应用运行期间则正常get和set，在卸载时保存当前变量恢复主应用变量，整个过程类似于中断和中断恢复。
            2. 通过proxy 代理，将数据挂载载以window的代理对象上
         5. 生命周期
         6. 子应用预加载
            1. 主应用开始后加载全部
            2. 加载子应用后加载选择的子应用
         7. 全局状态通信
            1. 通过添加事件总线，由主应用管理发布订阅事件。
      5. webpack 模块联邦 module Federation：主要是用来解决多个应用之间代码共享的问题，可以更加优雅的实现跨应用的代码共享，使用这个方法也可以实现微前端。
      6. web component
   3. ssr 服务端渲染：由服务器渲染出完整的首屏的`dom`结构并发送到浏览器的技术。
      1. 同构：在服务器和浏览器都能运行的代码。注意：页面能很快的展示出来，但是由于当前返回的只是单纯展示的DOM、CSS，其中的JS相关的事件等在客户端其实并没有绑定，所以最终还是需要JS加载完以后，对当前的页面再进行一次渲染，称为同构。 所以SSR就是更快的先展示出页面的内容，先让用户能够看到。
      2. 两种技术有大量可重用的代码，客户端路由、服务器端路由、客户端`Redux`、服务器端`Redux`等，最大程度的复用这些代码，就是同构。
      3. 解决问题：seo优化，利于爬虫抓取数据，首屏加载优化，减少首屏加载时间
      4. 流程：服务端fetch 数据，序列化路由组件并注入到模版html文件中，拼接成完整的html文件返回客户端，客户端二次渲染数据，同构页面组件，完成页面可交互的状态。
      5. CSR和SSR最大的区别在于前者的页面渲染是JS负责进行的，而后者是服务器端直接返回HTML让浏览器直接渲染。
   4. 权限控制：ACL权限控制列表，给角色添加一系列的权限。**RBAC**(Role Base Access Control):基于角色的权限控制，给定每个角色对应的权限，添加时设置不同的角色。**ABAC（Attribute Base Access Control）** 基于属性的权限控制。对角色添加不同的属性，属性之间可以组合在一起。
   5. TDD：测试驱动开发（Test-Driven Development），也就是说我们可以从测试的角度来检验整个项目。大概的流程是先针对每个功能点抽象出接口代码，然后编写单元测试代码，接下来实现接口
      BDD：行为驱动开发（Behavior Driven Development）
      ATDD：验收测试驱动开发（Acceptance Test Driven Development）
      DDD：领域驱动开发（Domain Drive Design）
   6. 单元测试一般关注的是单一的代码单元，一般可能是一个对象或者类的一个具体函数，这类关注单个函数的测试通常是简单的、容易书写并且可以快速运行的。
   7. **集成测试(Integration tests):** 一组需要运行多个测试进行验证的过程，通常是为了验证各个程序单元一起工作时的结果是否符合预期。
   8. **验收测试(Acceptance tests)/功能测试(Functional tests):**端到端测试  从用户视角对整个系统进行的测试，判断系统是否满足用户的验收条件。例如使用Selenium对Web应用进行自动化测试。
   9. TDD先写业务测试代码，根据预期结果编写业务代码，并在运行测试使其测试通过。在保证测试通过的情况下不断重构代码，保证代码质量。测试驱动开发是从开发人员的角度实施的测试方法或编程实践。在这种技术中，QA 工程师开始为应用程序的每个小功能设计和编写测试用例。自动化测试脚本是在功能性代码之前编写的。
      1. 有助于减少返工所需的时间
      2. 帮助快速探索错误或错误
      3. 帮助获得更快的反馈
      4. 导致创建灵活且易于维护的大量代码
   
   10. 行为驱动开发 (BDD) 是一种源自测试驱动开发 (TDD) 方法的测试方法。在 BDD 中，测试主要基于系统行为。这种方法定义了基于其行为开发功能的各种方法。在大多数情况下，Given-When-Then 方法用于编写测试用例。他以测试主体拥有什么行为为核心，编写测试时不关心细节代码和实现代码，取而代之的是关心测试主体的行为触发。单元测试回答的是What的问题，TDD回答的是When的问题，BDD回答的是How的问题。Given when then GWT 
       1. 通过使用非技术语言帮助覆盖更广泛的受众
       2. 从客户和开发人员的角度关注系统的行为方式
       3. 减少验证任何部署后缺陷所需的工作量
   
   11. ATDD 在验收测试驱动开发 (ATDD) 技术中，单个验收测试是从用户的角度编写的。它主要侧重于满足系统的功能行为。这种技术试图回答这个问题——代码是否按预期工作？BDD 更侧重于功能的行为，而 ATDD 侧重于捕获准确的需求。
       1. 需求分析非常清晰，没有任何歧义
       2. 鼓励跨团队成员之间的协作
       3. 验收测试作为整个开发过程的指南
   
   12. 敏捷开发：以较短的时间来执行项目从编写到测试通过并上线的流程，并能支持后续的迅速迭代。通常是以持续集成和持续交付为基础，每次交付测试和上线的增量足够的小，保证项目各部门始终处于运行状态且随时可以发布。敏捷开发的核心是迭代开发（iterative development）。敏捷一定是采用迭代开发的方式。迭代开发将一个大任务，分解成多次连续的开发，所谓"增量开发"，指的是软件的每个版本，都会新增一个用户可以感知的完整功能。也就是说，按照新增功能来划分迭代。
   13. ci **持续集成（CONTINUOUS INTEGRATION）**自动化测试、编译开发人员的每次提交并。CD **持续交付（CONTINUOUS DELIVERY）**随时随地的自动化部署项目，C D**持续部署（CONTINUOUS DEPLOYMENT）**合并ci cd
   14. next remix 
       1. 文件的约定式路由系统 ，Remix 路由是基于 react-router 构建的, 并且你可以直接使用 React Hooks, 比如 `useParams` 和 `useNavigate`。 另一方面, Remix 内置支持嵌套布局的嵌套路由，而next 则以pages目录为路由系统。
       2. next ssg ISR 
       3. remix 
          1. 文件系统路由
          2. 路由布局嵌套
          3. 自动拆分代码
          4. 数据驱动的元标签
          5. 内置数据加载
          6. 零配置构建
          7. React Refresh



