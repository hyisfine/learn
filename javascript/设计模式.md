1. 语言种类：静态类型、动态类型

   1. 静态类型：需要提前编译，编译时剔除死码，检查错误，更安全，优化运行速度。每个数据都需要定义类型，强调的是 数据是什么类型。面向类型编程。
   2. 动态类型：鸭子类型，一遍编译一遍运行，只有在运行时才知道数据是否有对应属性，强调数据有什么。面向接口编程。

2. 多态：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结 果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的 反馈。多态将“做什么”从“谁去做什么”分离开。多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而 消除这些条件分支语句。

3. 封装的目的是将信息隐藏。一般而言，我们讨论的封装是封装数据和封装实现。但封装不仅包括封装数据和封装实现，还包括封装类型和封装变化。

   1. 封装数据：封装pubic、private
   2. 封装行为：将过程代码封装为对象的方法，使用者只需调用方法而不必关心过程。
   3. 封装类型：把对象的真正类型隐藏在抽象类或者接口之后，相比对象的类型，客户更关心对象的行为，比如工厂模式、组合模式。
   4. 封装变化：将可能发生变化的部分封装，在将来变化时直接移除封装的部分。业务代码中，将条件分支相关的代码封装为新的组件或方法。

4. 基于原型编码的规范

   1. 所有的数据都是对象
   2. 创建一个对象不是实例化一个类，而是将另一个对象作为原型并克隆它
   3. 对象会记住他的原型
   4. 调用对象属性时会从原型链上寻找属性（委托原型

5. AOP 面向切面编程：将于核心业务无关的功能模块分离出来，运行时，动态地将功能模块切入到业务的指定方法、指定位置上的编程思想就是面向切面的编程。 

   ```js
   Function.prototype.before = function( beforefn ){
   var __self = this; // 保存原函数的引用
   return function(){ // 返回包含了原函数和新函数的"代理"函数
    beforefn.apply( this, arguments ); return __self.apply( this, arguments );
   Function.prototype.after = function( afterfn ){ var __self = this;
   return function(){
   // 执行新函数，修正 this // 执行原函数
   } };
   var ret = __self.apply( this, arguments ); afterfn.apply( this, arguments );
   return ret;
   } };
   var func = function(){ console.log( 2 );
   };
   func = func.before(function(){ console.log( 1 );
   }).after(function(){ console.log( 3 );
   }); func();
   ```

6. 函数curry：部分求值。一个 currying 的函数首先会接受一些参数，接受了这些参数之后， 该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保 存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。

7. 函数uncurry：js可以通过call、bind、apply使对象执行它没有的方法。但是使用时需要指定this指向。通过uncurry去this化，可以不必指定this。

   ```js
   Function.prototype.uncurrying = function () { 
     var self = this;
   	return function() {
   		var obj = Array.prototype.shift.call( arguments );
       return self.apply( obj, arguments );
   }; };
   ```

8. 单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。非透明性、透明性

   1. 惰性单例指的是在需要的时候才创建对象实例
   2. 分离创建对象和管理单例

9. 策略模式：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。用于调用同一种行为的不同实现方法。比如document.createElement 。一般需要一个context 和一个策略组。业务中的tab切换就算一种策略。获取根据 后端字段展示不同的数据。可以理解为，将条件分支分离开，每次执行将条件和分支代码传入context。对多态的应用：策略组每个对象都有相同的方法不同的逻辑。表单验证时，传入不同的验证函数和数据。

   1. 策略模式使用组合、委托和多态等手段，将条件逻辑里的条件和代码分支拆除出来，分别传入给处理对象。
   2. 使用者需要清楚各策略方案的区别。

10.   代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身 对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之 后，再把请求转交给本体对象

    1. 保护代理：过滤对代理对象不好的请求和操作。
    2. 虚拟代理：
    3. 缓存代理

11. 迭代模式：迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象 5 的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。

12. 发布订阅模式：发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状 态发生改变时，所有依赖于它的对象都将得到通知。比如dom事件

13. 命令模式：命令模式是最简单和优雅的模式之一，命令模式中的命令(command)指的是一个执行某些特定事情的指令。将特定的代码和运算封装成函数，对不同的操作调用不同的命令函数。提供一个command对象，调用不同的命令执行不同的操作。与策略模式的有所区别。将调用者与提供者分离开。调用者不关心提供者是谁，只关心调用的命令。键盘的输入。

14. 组合模式：以某种形式或某种模式嵌套执行响应的操作。组合模式将对象组合成树形结构，以表示“部分整体”的层次结构。使得用户对单个对象和组合对象的使 用具有一致性。能够形成组合模式的条件是调用者和提供者有相同的接口。对整体操作时、不必在意部分之间的区别。

15. 模版方法模式：模板方法模式是一种只需使用继承就可以实现的非常简单的模式。模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常 在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺 序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。

16. 好莱坞原则：高层调用底层

17. 职责链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间 5 的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

​	