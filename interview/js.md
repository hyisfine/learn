1. 执行上下文和作用域链。每一个函数的调用都会生一个自己的执行上下文，而每一个执行上下文都会生成属于自己的一个变量对象(初始时只有arguments)（全局的变量对象，函数的活动对象），存放在当前上下文定义的变量和函数。当执行到当前函数时，上下文会被压入执行上下文栈中，当函数执行结束后又会弹出栈，而在压入栈的时候，栈内的所有执行上下文的变量对象会连接在一起创建一条作用域链，决定了当前上下文能够访问到的变量和函数。
2. var，声明范围是函数作用域，全局绑定在window下，可以不加var。变量提升。let 声明范围块作用域。不可重复声明，存在暂时性死区。const 必须初始化。变量提升都存在，即在进入函数创建执行上下文时，会先扫描函数里的变量声明，但是let 和const的变量此时并没有初始化，所以报错。
3. this对象是执行上下文中的一个属性，是指向的实际调用当前函数的对象或变量。通过new 、apply、bind、call、属性访问、或者无调用对象判断它的值。其中需要的注意的时候箭头函数没有this指向，也不能作为构造函数被new调用，它的this指向不可更改，永远指向定义函数时所在的执行上下文。本质是reference类型，返回base
4. 尖头函数。缩写、简写、this不可更改、无arguments、无constructor、不可构造、不可成为生成器函数、无prototype
5. 事件流，捕获、到达、冒泡。on Click add Listener ，batch。
6. 闭包指引用了另一个函数中的变量的函数。创建闭包时，他的作用域链上会有另外一个函数的活动对象，所以导致另一个函数的上下文和作用链被销毁，但是活动对象保留的情况。
7. 严格模式。提高效率。消除不合理的错误。
   1. class module默认严格模式
   2. this不指向window
   3. 函数参数使用默认值，rest时不可以时严格模式。
   4. 变量不可以直接定义
8. 创建对象 工厂模式、构造函数、对象字面量，原型链。
9. 继承。原型链、构造函数、组合、原型式、寄生、寄生组合。
10. 路由模式：hash、history。url不一样、hash可以做锚点定位。history需要服务器配置。popstate不会在push、replace时触发。
11. 隐形转换。主要有三种转换:ToPrimitive、toNumber、toString。后两种是针对基本类型。boolean、string、null、undefied转数字。to Primate，根据对象内部实现的方法，一般是先执行valueof然后执行to String（）。然后根据另外一边判断toString还是to Number。date先执行的string。
12. 通过Object.prototype.tostring.call判断实际类型。实质上是返回对象的toStringTag
13. 迭代器，实现iterable接口的结构都被称为可迭代对象。生成器，拥有暂停、恢复代码运行的结构。内部也是实现了迭代器。
14. json，序列化数据的一种格式。stringily，三个参数。不可循环、函数、symbol、undefined。第二参数可以是个数组。parse，第二参数可以控制返回值。加快json的方法：人为的构建字符串。
15. 任务队列，由于js是单线程的，一次只能运行一个任务。所以无法同时处理异步事件，于是遇到一个异步事件后，将会放入任务队列中，当当前的任务执行完成后循环执行任务队列里的任务。任务的入队通过其他线程实现、定时器、事件、网络线程。事件循环是js为了按照顺序执行各异步、同步代码的形成的机制。宏任务主函数、time、ui render、postMessage、微任务promise、MutaionObserver。
16. 模块化解决的问题：全局变量污染、变量命名冲突、便于代码维护、代码封装、代码复用。
    1. commonjs，社区方案，同步获取代码，通过module.exports 和require。
    2. AMD异步获取代码。define(name,依赖，code)。依赖前置
    3. CMD异步获取代码。依赖就近。
    4. es module，原生模块。静态分析和编译时加载。
    5. 区别：commonjs社区方案，运行时加载，值的拷贝。es module编译时加载，通过静态分析在解析阶段就知道了模块的值。
17. mvvm、mvc、mvp。都是应用的架构模式。都是对应用的不同职责进行的划分
    1. mvc。v->c->m->c，单向连接。
    2. mvp。v->p->m->p->v双向连接，vm断开，通过接口连接。
    3. mvvm，本质是对p层的进一步封装。讲m->p->v和v->p-m这一层交由架构完成。
18. 设计模式
    1. 单一职能原则、开闭原则、
    2. 工厂模式、观察者订阅发布redux trigger、单例redux、装饰器ts、代理proxy、访问者babel visitor
19. esm原理
    1. 在构建阶段通过entry文件，搜索下载所有的依赖文件并生成叫做模块记录的数据结构。
    2. 在实例化阶段为所有的模块分配内存空间，并通过导入导出语句链接各个内存空间。
    3. 运行代码，为分配的内存空间赋值。

> js
>
> 变量或函数的执行上下文控制他们可访问的数据和可执行的行为。每个函数在执行时都会产生一个相关的执行上下文，同时会以函数的arguments参数为基础创建一个活动对象，此后函数里创建的变量和函数都会挂在到当前对象中。函数产生执行上下文后，会将上下文压入一个执行上下文栈中，遵循后入先出的原则。函数的上下文在上下文栈中时，其活动对象会与栈内的每个上下文所携带的活动对象会链接在一起，形成一条作用域链，其决定了当前上下文可以访问到的变量和函数以及他们的顺序。
>
> 类型。基础类型number、bool、symbol、string、null、undefined、bigint。引用类型objet、tuple、record。
>
> var const let区别。var的声明范围是函数作用域，let、const的作用域是块级作用域。var、let const都存在变量提升，但let const由于暂时性死区的关系提升了但是没有设置初始值不可以使用。let const不可重复声明，const必须声明时赋值切不可更改，但引用对象可以更改内部的属性。
>
> this对象。this对象时执行上下文中的一个属性，指向实际调用当前函数的对象。一般通过new、bind、call、apply和对象的属性调用以及普通函数调用来判断this的指向问题。实际上，在js中存在一种reference规范类型，它的作用是描述js里的各种操作行为。他有几个重要的值，一个是当前base 属性的所属对象或环境。一个name。根据js的描述，在判断函数的this指向时，会根据函数调用时的操作是否为一个reference类型，如果不是则指向undefined，如果是则指向base对应的对象，如果base是环境，则指向undefined。
>
> 箭头函数vs普通函数。箭头函数有简单缩写、不可以做构造函数、生成器函数。没有arguments、prototype。this指向在创建之初就已确定不可更改。
>
> 闭包。一个函数能调用另外一个函数内部定义的变量就称之为闭包。在形成闭包函数的作用链时，会链接访问的函数的活动变量对象，导致在访问函数的执行上下文退出栈之后活动对象依旧被保留的情况。
>
> 原型链。实例对象的_ _ proto _ _指向其构造函数的prototype属性，而构造函数的_  _ proto _ _又会指向其构造函数的prototype，最终指向object的prototype，而object的prototype指向的是null。这样通过prototype和 proto的链接关系，形成了一条原型链。对象在访问某个属性时，会随着原型链层层往下查找。
>
> 严格模式。以更严格的代码规范和语法规范检查代码。目的是为了提前发现错误，并为向后兼容做准备。变量必须声明、不可修改arguments、对象的键名不可重复、this指向不再强制转换为顶层对象。类和模块默认是严格模式的。函数的可选参数不可以是严格模式。
>
> 创建对象。工厂函数、子面量对象、构造函数、原型链。
>
> 对象继承。原型链、构造函数、组合、原型式、寄生、寄生组合。
>
> 路由模式。hash、监听onhashchange。history，触发push、replacestate，监听popstate。
>
> 隐形转换。分为四种种转换，引用类型转为基础类型。基础类型转string、number，条件语句转为bool。内部有一个toprimite函数控制转化流程。一般来说先转为number，执行value of如果返回的还是引用着执行头tostring方法。但是date是个例外。它先执行的tostring。
>
> object对象。getownprototypenames、hasownprototype、frezz冻结、getPrototypeOf、hasown、is、assign。
>
> 迭代器。迭代，指可以循环执行同一段代码的操作。for 循环是简单的一个迭代。内部实现了迭代协议的对象称为可迭代对象，如arr，map、字符串等。同时我们也可以自定义迭代协议，只要返回一个包含next方法的对象就可以。
>
> 生成器。是js一个可以控制代码暂停和恢复执行的功能。他和迭代器一样，是在内部实现了迭代器协议的一个特殊的函数。通过yield关键字进行代码执行控制。实现原理：通过switich返回一个包含next方法 的对象。async、await本质上是生成器函数和promise实现的语法糖。
>
> json。人为构造字符串的形式加快json转化。stringily有两个参数，第二个参数可以是个数组，包含需要保留的键。也可以是个操控函数，可以控制最终生成的json字符串。函数、undefined、symbol转化为null、错误不可转化、不可以转化循环引用对象。
>
> 任务队列、事件循环。是js为了实现异步代码和同步代码按某种顺序执行的机制。函数在执行过程中会被压入到调用栈中，而异步函数则交由相应的线程处理，并在处理完成后将回调函数加入到任务队列队列中。js主函数执行完毕后会循环执行人物队列里的函数，并压入到调用栈中。微任务：promise、MutationObserver。宏任务，代码块、定时器、ui刷新 postmassage。
>
> mvvm、mvc、mvp。mvvm架构是mvp架构的进一步封装。在mvp架构中，m层与p层的通信和p层与v层的通信需要调用相应的接口触发相应的事件，在mvvm架构中，框架整合了调用接口触发事件这一行为，开发者 不必关心如何调用接口。m层的变化和v层的操作会直接影响到对方。
>
> 模块化。解决全局变量污染和命名冲突问题，同时便于代码维护、代码封装和代码复用。commonjs 社区的方案，同步调用模块。amd异步调用依赖前置 、cmd依赖就近。es module 原生的模块方案。区别，commonjs本质是将代码重新包裹到一个函数中，调用时执行函数，所以它返回的值是一个拷贝，且运行时加载。es module返回的是值的应用，且在编译阶段就能对值和导出变量进行引用链接。所以返回的是变量的值的引用。且是编译时加载。
>
> es module原理。先是通过entry文件递归搜集并下载所有的依赖模块。在分析模块代码实例化阶段为模块的导出对象分配空间。同时通过模块的导入和导出关联空间。运行代码，为分配的空间赋值。es module 是异步原因：模块的导入需要经历三个阶段。在CommonJS里面，对于一个模块和它底下的依赖来说，下载，实例化，和求值都是一次性完成的，步骤相互之间没有任何停顿。
>
> 设计模式。遵循solid原理。单一职能、开闭。工厂模式、单例、发布订阅、装饰器、代理者、访问者模式。
>
> js堆与栈：数据结构上的两种数据结构，栈先入后出，堆按照某种关系比较进行数据的出入堆。在js中，栈存储基本数据类型，按具体的值访问数据，具有先入后出的顺序，空间大小固定，数据出栈时空间释放。堆存储引用数据类型，按引用的指针访问数据，空间大小不确定，无序存储，空间的释放需要专门的算法处理回收。
>
> 为什么object慢？因为不是索引，而是遍历属性，然后再从prototype往下遍历。缓存对象键。