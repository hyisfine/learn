1. 安装：curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

2. 更新 ：rustup update

3. Cargo：Rust 的构建工具和包管理器

4. rustc 管理工具

5. Rust 源文件总是以 *.rs* 扩展名结尾。如果文件名包含多个单词，那么按照命名习惯，应当使用下划线来分隔单词。

6. cargo check 只检查语法 run生成二进制并运行   build  生成二进制 new 创建项目

7. 当项目最终准备好发布时，可以使用 `cargo build --release` 来优化编译项目。

8.  在 Rust 中，变量默认是不可变的，这意味着一旦我们给变量赋值，这个值就不再可以修改了。

9. 正如第二章中[“使用变量储存值”](https://kaisery.github.io/trpl-zh-cn/ch02-00-guessing-game-tutorial.html#使用变量储存值) 部分提到的那样，let变量默认是不可改变的（immutable）。 添加mut

10. let 不可变变量。可通过添加mut 改变。const 不可变常量 不允许对常量使用 `mut`，*必须* 注明值的类型。重复的声明let 会 隐藏 前一个声明。块级声明。

    `mut` 与隐藏，当再次使用 `let` 时，实际上创建了一个新变量。

11. 两类数据类型子集：标量（scalar）和复合（compound）。

    1. **标量**（*scalar*）类型代表一个单独的值。Rust 有四种基本的标量类型：整型、浮点型、布尔类型和字符类型。
    2. 数字允许使用类型后缀，例如57u8 来指定类型，同时也允许使用 _ 做为分隔符以方便读数，例如1_000
    3. 我们用单引号声明 `char` 字面量，而与之相反的是，使用双引号声明字符串字面量。
    4. **复合类型**（*Compound types*）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。
    5. 元组是一个将多个其他类型的值组合进一个复合类型的主要方式。元组长度固定：一旦声明，其长度不会增大或缩小。let （a,b,c）解构
    6. 另一个包含多个值的方式是 **数组**（*array*）。与元组不同，数组中的每个元素的类型必须相同。Rust 中的数组与一些其他语言中的数组不同，Rust中的数组长度是固定的。
    7. let a: [i32; 5] = [1, 2, 3, 4, 5];let a = [3; 5];
    8. **。当尝试用索引访问一个元素时，Rust 会检查指定的索引是否小于数组的长度。如果索引超出了数组长度，Rust 会 *panic*，这是 Rust 术语，它用于程序因为错误而退出的情况。**

12. Rust 代码中的函数和变量名使用 *snake case* 规范风格。

13. 函数

    1. 源码中 `another_function` 定义在 `main` 函数 **之后**；也可以定义在之前。Rust 不关心函数定义所在的位置，只要函数被调用时出现在调用之处可见的作用域内就行。
    2. 在函数签名中，**必须** 声明每个参数的类型

14. rust是基于表达式的言语， **语句**（*Statements*）是执行一些操作但不返回值的指令。表达式（*Expressions*）计算并产生一个值。添加分号标识为一个语句。

15. 函数调用是一个表达式。宏调用是一个表达式。用大括号创建的一个新的块作用域也是一个表达式.

16. 函数可以向调用它的代码返回值。我们并不对返回值命名，但要在箭头（`->`）后声明它的类型。在 Rust 中，函数的返回值等同于函数体最后一个表达式的值。

17. 控制流程：i没有括号。代码中的条件 **必须** 是 `bool` 值。如果条件不是 `bool` 值

18. 因为 `if` 是一个表达式，我们可以在 `let` 语句的右侧使用它，例如在示例 3-2 中：

19. Rust 有三种循环：`loop`、`while` 和 `for`。

20. 所有权

    1. Rust 中的每一个值都有一个被称为其 **所有者**（*owner*）的变量。
    2. 值在任一时刻有且只有一个所有者。
    3. 当所有者（变量）离开作用域，这个值将被丢弃。

21. 当 `s2` 和 `s1` 离开作用域，他们都会尝试释放相同的内存。这是一个叫做 **二次释放**（*double free*）的错误，也是之前提到过的内存安全性 bug 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。

22. 不过因为 Rust 同时使第一个变量无效了，这个操作被称为 **移动**（*move*），而不是浅拷贝。

23. 可变引用有一个很大的限制：在同一时间只能有一个对某一特定数据的可变引用。这些尝试创建两个 `s` 的可变引用的代码会失败：

24. 防止同一时间对同一数据进行多个可变引用的限制允许可变性，不过是以一种受限制的方式允许。新 Rustacean 们经常难以适应这一点，因为大部分语言中变量任何时候都是可变的。这个限制的好处是 Rust 可以在编译时就避免数据竞争。**数据竞争**（*data race*）类似于竞态条件，它可由这三个行为造成：

    - 两个或更多指针同时访问同一数据。
    - 至少有一个指针被用来写入数据。
    - 没有同步数据访问的机制。

25. 我们 **也** 不能在拥有不可变引用的同时拥有可变引用。

26. 编译器在作用域结束之前判断不再使用的引用的能力被称为 **非词法作用域生命周期**（*Non-Lexical Lifetimes*，简称 NLL）。你可以在 [The Edition Guide](https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/non-lexical-lifetimes.html) 中阅读更多关于它的信息。

27. 在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个 **悬垂指针**（*dangling pointer*），所谓悬垂指针是其指向的内存可能已经被分配给其它持有者。

28. 使用没有命名字段的元组结构体来创建不同的类型

