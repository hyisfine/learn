1. 推送比较：轮训、长轮训、websocket、http2、fetch readStream getReader、sse

   1. 短轮询(Polling)的实现思路就是浏览器端每隔几秒钟向服务器端发送http请求，服务端在收到请求后，不论是否有数据更新，都直接进行响应。在服务端响应完成，就会关闭这个Tcp连接，操作简单，消耗资源非实时
   2. 长轮询，客户端发送请求后服务器端不会立即返回数据，服务器端会阻塞请求连接不会立即断开，直到服务器端有数据更新或者是连接超时才返回，客户端才再次发出请求新建连接、如此反复从而获取最新数据。减少请求次数，hold是会消耗资源。
   3. 基于iframe的长连接流（stream）模式，通过定义父页面的函数，然后引入一个iframe，向页面中写入script，执行副页面的函数。页面会一致有个loading
   4. websocket，双工通信的协议。更强大和灵活。因为它是全双工通道，可以双向通信；扩展性高，但是配置复杂，不可以自定义消息。
   5. SSE 是单向通道基于数据流的，不是一次发送完整的包，而是通过信息流的形式不断发送信息，前端不断监听事件，：onmessage。类似于文件下载。只能服务器向浏览器发送，因为流信息本质上就是下载。如果浏览器向服务器发送信息，就变成了另一次 HTTP 请求。可自定义消息事件。基于http，配置简单，一般用来传输文本，二进制数据需要编码。 默认支持断线重连。
   6. http2，需要手动配置。配置复杂，服务器推送有一个很麻烦的问题。所要推送的资源文件，如果浏览器已经有缓存，推送就是浪费带宽。即使推送的文件版本更新，浏览器也会优先使用本地缓存。

2. 基于HTTP长连接、无须在浏览器端安装插件的“服务器推”技术为“Comet”。 常用的COMET分为两种：基于HTTP的长轮询（long-polling）技术，以及基于iframe的长连接流（stream）模式。

3. sse ，`HTTP 协议`无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息（streaming）。发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，SSE 就是利用这种机制，使用流信息向浏览器推送信息。

   1. Cache-Control中需要包含no-transform，没有这个的话在开发中，如果你用了create-react-app等工具来转发你的请求，那么你的数据流很可能被压缩，造成你怎么也收不到响应。

4. 区别

   1. SSE 使用 HTTP 协议，现有的服务器软件都支持。WebSocket 是一个独立协议。双工通信。
   2. SSE 属于轻量级，使用简单；WebSocket 协议相对复杂。
   3. SSE 默认支持断线重连，WebSocket 需要自己实现。
   4. SSE 一般只用来传送文本，二进制数据需要编码后传送，WebSocket 默认支持传送二进制数据。
   5. SSE 支持自定义发送的消息类型。

5. ```js
   Content-Type: text/event-stream
   Cache-Control: no-cache,no-transfrom
   Connection: keep-alive
   ```

   必须添加的header

7. 每一次发送的信息，由若干个`message`组成，每个`message`之间必须用`\n\n`分隔。每个`message`内部由若干行组成，每一行都是如下格式。
8. 支持的字段：data、event、id、retry，还有冒号开头的行，表示注释。服务器可以用retry字段，指定浏览器重新发起连接的时间间隔。
9. SSE 要求服务器与浏览器保持连接。对于不同的服务器软件来说，所消耗的资源是不一样的。Apache 服务器，每个连接就是一个线程，如果要维持大量连接，势必要消耗大量资源。Node 则是所有连接都使用同一个线程，因此消耗的资源会小得多，但是这要求每个连接不能包含很耗时的操作，比如磁盘的 IO 读写。
10. 当**不通过 HTTP/2 使用时**，SSE 会受到打开连接的最大数量的限制，这在打开多个选项卡时尤其痛苦，因为限制是针对*每个浏览器*的并且设置为非常低的数字 (6) . 
11. 事件流是一个简单的文本数据流，必须使用[UTF-8](https://developer.mozilla.org/en-US/docs/Glossary/UTF-8)进行编码。
12. sse有默认的延时，但我并没有找到相对应的官网信息。
13. 