1. 执行上下文和作用域链。每一个函数的调用都会生一个自己的执行上下文，而每一个执行上下文都会生成属于自己的一个变量对象(初始时只有arguments)（全局的变量对象，函数的活动对象），存放在当前上下文定义的变量和函数。当执行到当前函数时，上下文会被压入执行上下文栈中，当函数执行结束后又会弹出栈，而在压入栈的时候，栈内的所有执行上下文的变量对象会连接在一起创建一条作用域链，决定了当前上下文能够访问到的变量和函数。
2. var，声明范围是函数作用域，全局绑定在window下，可以不加var。变量提升。let 声明范围块作用域。不可重复声明，存在暂时性死区。const 必须初始化。变量提升都存在，即在进入函数创建执行上下文时，会先扫描函数里的变量声明，但是let 和const的变量此时并没有初始化，所以报错。
3. this对象是执行上下文中的一个属性，是指向的实际调用当前函数的对象或变量。通过new 、apply、bind、call、属性访问、或者无调用对象判断它的值。其中需要的注意的时候箭头函数没有this指向，也不能作为构造函数被new调用，它的this指向不可更改，永远指向定义函数时所在的执行上下文。本质是reference类型，返回base
4. 尖头函数。缩写、简写、this不可更改、无arguments、无constructor、不可构造、不可成为生成器函数、无prototype
5. 事件流，捕获、到达、冒泡。on Click add Listener ，batch。
6. 闭包指引用了另一个函数中的变量的函数。创建闭包时，他的作用域链上会有另外一个函数的活动对象，所以导致另一个函数的上下文和作用链被销毁，但是活动对象保留的情况。
7. 严格模式。提高效率。消除不合理的错误。
   1. class module默认严格模式
   2. this不指向window
   3. 函数参数使用默认值，rest时不可以时严格模式。
   4. 变量不可以直接定义
8. 创建对象 工厂模式、构造函数、对象字面量，原型链。
9. 继承。原型链、构造函数、组合、原型式、寄生、寄生组合。
10. 路由模式：hash、history。url不一样、hash可以做锚点定位。history需要服务器配置。popstate不会在push、replace时触发。
11. 隐形转换。主要有三种转换:ToPrimitive、toNumber、toString。后两种是针对基本类型。boolean、string、null、undefied转数字。to Primate，根据对象内部实现的方法，一般是先执行valueof然后执行to String（）。然后根据另外一边判断toString还是to Number。date先执行的string。
12. 通过Object.prototype.tostring.call判断实际类型。实质上是返回对象的toStringTag
13. 迭代器，实现iterable接口的结构都被称为可迭代对象。生成器，拥有暂停、恢复代码运行的结构。内部也是实现了迭代器。
14. json，序列化数据的一种格式。stringily，三个参数。不可循环、函数、symbol、undefined。第二参数可以是个数组。parse，第二参数可以控制返回值。加快json的方法：人为的构建字符串。
15. 

